Index: pkg/usecase/dependency.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2018-2022 SCANOSS.COM\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npackage usecase\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strings\"\n\n\t\"github.com/scanoss/go-grpc-helper/pkg/grpc/database\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t\"go.uber.org/zap\"\n\tmyconfig \"scanoss.com/dependencies/pkg/config\"\n\t\"scanoss.com/dependencies/pkg/dtos\"\n\t\"scanoss.com/dependencies/pkg/models\"\n)\n\ntype DependencyUseCase struct {\n\tctx     context.Context\n\ts       *zap.SugaredLogger\n\tconn    *sqlx.Conn\n\tallUrls *models.AllUrlsModel\n\tlic     *models.LicenseModel\n}\n\n// NewDependencies creates a new instance of the Dependency Use Case.\nfunc NewDependencies(ctx context.Context, s *zap.SugaredLogger, db *sqlx.DB, conn *sqlx.Conn, config *myconfig.ServerConfig) *DependencyUseCase {\n\treturn &DependencyUseCase{ctx: ctx, s: s, conn: conn,\n\t\tallUrls: models.NewAllURLModel(ctx, s, conn, models.NewProjectModel(ctx, s, conn),\n\t\t\tmodels.NewGolangProjectModel(ctx, s, db, conn, config),\n\t\t\tdatabase.NewDBSelectContext(s, db, conn, config.Database.Trace),\n\t\t),\n\t\tlic: models.NewLicenseModel(ctx, s, conn),\n\t}\n}\n\n// GetDependencies takes the Dependency Input request, searches for component details and returns a Dependency Output struct.\nfunc (d DependencyUseCase) GetDependencies(request dtos.DependencyInput) (dtos.DependencyOutput, bool, error) {\n\tvar depFileOutputs []dtos.DependencyFileOutput\n\tvar problems = false\n\td.s.Infof(\"Processing %v dependency files...\", len(request.Files))\n\tfor _, file := range request.Files {\n\t\tvar fileOutput dtos.DependencyFileOutput\n\t\tfileOutput.File = file.File\n\t\tfileOutput.ID = \"dependency\"\n\t\tfileOutput.Status = \"pending\"\n\t\tvar depOutputs []dtos.DependenciesOutput\n\t\td.s.Infof(\"Processing %v purls for %v...\", len(file.Purls), file.File)\n\t\tfor _, purl := range file.Purls {\n\t\t\tif len(purl.Purl) == 0 {\n\t\t\t\td.s.Infof(\"Empty Purl string supplied for: %v. Skipping\", file.File)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar depOutput dtos.DependenciesOutput\n\t\t\tdepOutput.Purl = strings.Split(purl.Purl, \"@\")[0] // Remove any version specific info from the PURL\n\t\t\turl, err := d.allUrls.GetURLsByPurlString(purl.Purl, purl.Requirement)\n\t\t\tif err != nil {\n\t\t\t\td.s.Warnf(\"Problem encountered extracting URLs for: %v, %v - %v.\", file.File, purl, err)\n\t\t\t\tproblems = true // Record this as a warning\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdepOutput.Component = url.Component\n\t\t\tdepOutput.Version = url.Version\n\t\t\tdepOutput.URL = url.URL\n\t\t\tvar licenses []dtos.DependencyLicense\n\t\t\tsplitLicenses := strings.Split(url.LicenseID, \"/\") // Check to see if we have multiple licenses returned\n\t\t\tif len(splitLicenses) > 1 {\n\t\t\t\tfor _, splitLicense := range splitLicenses {\n\t\t\t\t\tspl := strings.TrimSpace(splitLicense)\n\t\t\t\t\td.s.Debugf(\"Searching for split license: %v\", spl)\n\t\t\t\t\tlic, err := d.lic.GetLicenseByName(spl, false)\n\t\t\t\t\tif err != nil || len(lic.LicenseName) == 0 {\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\td.s.Warnf(\"Problem encountered searching for license %v (%v): %v\", spl, splitLicense, err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar license dtos.DependencyLicense\n\t\t\t\t\t\tlicense.Name = spl\n\t\t\t\t\t\tlicense.SpdxID = spl\n\t\t\t\t\t\tlicense.IsSpdx = false\n\t\t\t\t\t\tlicenses = append(licenses, license)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar license dtos.DependencyLicense\n\t\t\t\t\t\tlicense.Name = lic.LicenseName\n\t\t\t\t\t\tlicense.SpdxID = lic.LicenseID\n\t\t\t\t\t\tlicense.IsSpdx = lic.IsSpdx\n\t\t\t\t\t\tlicenses = append(licenses, license)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar license dtos.DependencyLicense\n\t\t\t\tlicense.Name = url.License\n\t\t\t\tlicense.SpdxID = url.LicenseID\n\t\t\t\tlicense.IsSpdx = url.IsSpdx\n\t\t\t\tlicenses = append(licenses, license)\n\t\t\t}\n\t\t\tdepOutput.Licenses = licenses\n\t\t\tdepOutputs = append(depOutputs, depOutput)\n\t\t}\n\t\tfileOutput.Dependencies = depOutputs\n\t\tdepFileOutputs = append(depFileOutputs, fileOutput)\n\t}\n\td.s.Debugf(\"Output dependencies: %v\", depFileOutputs)\n\tif problems {\n\t\td.s.Warnf(\"Encountered issues while processing dependencies: %v\", request)\n\t\treturn dtos.DependencyOutput{Files: depFileOutputs}, true, errors.New(\"encountered issues while processing dependencies\")\n\t}\n\n\treturn dtos.DependencyOutput{Files: depFileOutputs}, false, nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/usecase/dependency.go b/pkg/usecase/dependency.go
--- a/pkg/usecase/dependency.go	(revision f9a292a53564bc5a079fc98461f4ff95a40cc6b6)
+++ b/pkg/usecase/dependency.go	(date 1749037118869)
@@ -75,8 +75,19 @@
 				continue
 			}
 			depOutput.Component = url.Component
-			depOutput.Version = url.Version
 			depOutput.URL = url.URL
+			if len(url.Version) > 0 {
+				depOutput.Version = url.Version
+			} else {
+				purlParts := strings.Split(purl.Purl, "@")
+				if len(purlParts) > 1 {
+					depOutput.Version = purlParts[1]
+				} else if len(purl.Requirement) > 0 {
+					depOutput.Version = purl.Requirement
+				} else {
+					depOutput.Version = "unknown"
+				}
+			}
 			var licenses []dtos.DependencyLicense
 			splitLicenses := strings.Split(url.LicenseID, "/") // Check to see if we have multiple licenses returned
 			if len(splitLicenses) > 1 {
